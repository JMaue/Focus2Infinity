@page "/editor/{Topic}/{Name}"
@using Focus2Infinity.Data
@using Focus2Infinity
@using Focus2Infinity.Options
@using Microsoft.Extensions.Options
@using System.Globalization
@using System.Text.Json
@using System.Net
@inject F2IDataService f2iDataService
@inject IStringLocalizer<SharedResource> L
@inject NavigationManager Navigation
@inject IJSRuntime JS
@inject IOptions<OverlayEditorOptions> OverlayEditorOptions

@rendermode InteractiveServer

@if (!OverlayEditorOptions.Value.Enabled)
{
  <p class="my-3">The Overlay Editor is not available on this server. It is only enabled when running locally.</p>
  <p><a href="/">Back to home</a></p>
}
else
{
  <div class="container-fluid">
    @* Toolbar *@
    <div class="row mb-3">
      <div class="col-12">
        <div class="d-flex gap-2 flex-wrap align-items-center">
          <a href="@ImageDetailsUrl" class="btn btn-outline-secondary">Back to image</a>
          <span class="text-muted">@Name</span>
          <div class="btn-group" role="group">
            <button type="button" class="btn @(_tool == EditorTool.Line ? "btn-primary" : "btn-outline-primary")" @onclick='() => _tool = EditorTool.Line'>Line</button>
            <button type="button" class="btn @(_tool == EditorTool.Circle ? "btn-primary" : "btn-outline-primary")" @onclick='() => _tool = EditorTool.Circle'>Circle</button>
            <button type="button" class="btn @(_tool == EditorTool.Text ? "btn-primary" : "btn-outline-primary")" @onclick='() => _tool = EditorTool.Text'>Text</button>
          </div>
          <label class="d-flex align-items-center gap-1">
            Color <input type="color" @bind="_strokeColor" class="form-control form-control-color" style="width:2.5rem;height:2.5rem" />
          </label>
          <label class="d-flex align-items-center gap-1">
            Stroke <input type="number" @bind="_strokeWidth" @bind:event="oninput" min="0.5" max="20" step="0.5" class="form-control" style="width:4rem" />
          </label>
          <label class="d-flex align-items-center gap-1">
            Font size <input type="number" @bind="_fontSize" @bind:event="oninput" min="8" max="72" class="form-control" style="width:4rem" />
          </label>
          <button class="btn btn-outline-secondary" @onclick="Undo" disabled="@(_undoStack.Count == 0)">Undo</button>
          <button class="btn btn-success" @onclick="Save">Save</button>
        </div>
      </div>
    </div>

    @* Canvas and Elements Panel *@
    <div class="row">
      <div class="col-lg-9 col-md-8">
        <div id="canvas-container" 
             style="position:relative;width:100%;cursor:crosshair;background-color:#1a1a1a;"
             @onmousedown="OnCanvasMouseDown"
             @onmousemove="OnCanvasMouseMove"
             @onmouseup="OnCanvasMouseUp"
             @onmouseleave="OnCanvasMouseLeave">

          <img id="editor-image" 
               src="@_imageUrl" 
               alt="" 
               style="width:100%;height:auto;display:block;pointer-events:none;" />

          @if (_crosshairX.HasValue && _crosshairY.HasValue)
          {
            <div class="position-absolute" 
                 style="left:@(_crosshairX.Value)px;top:@(_crosshairY.Value)px;transform:translate(-50%,-50%);width:21px;height:21px;pointer-events:none;">
              <svg viewBox="0 0 21 21" style="display:block;filter:drop-shadow(0 0 1px black);">
                <line x1="0" y1="10" x2="9" y2="10" stroke="white" stroke-width="1" />
                <line x1="11" y1="10" x2="21" y2="10" stroke="white" stroke-width="1" />
                <line x1="10" y1="0" x2="10" y2="9" stroke="white" stroke-width="1" />
                <line x1="10" y1="11" x2="10" y2="21" stroke="white" stroke-width="1" />
              </svg>
            </div>
          }

          <svg id="overlay-svg" 
               style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none">
            @foreach (var line in _overlay.Lines)
            {
              <line x1="@SvgPct(line.X1)" y1="@SvgPct(line.Y1)" 
                    x2="@SvgPct(line.X2)" y2="@SvgPct(line.Y2)" 
                    stroke="@line.Color" 
                    stroke-width="@SvgNum(line.StrokeWidth)" />
            }
            @foreach (var circle in _overlay.Circles)
            {
              <circle cx="@SvgPct(circle.Cx)" cy="@SvgPct(circle.Cy)" 
                      r="@SvgPct(circle.Radius)" 
                      stroke="@circle.Color" 
                      stroke-width="@SvgNum(circle.StrokeWidth)" 
                      fill="@(circle.Fill ? circle.Color : "none")" />
            }
            @foreach (var text in _overlay.Texts)
            {
              @((MarkupString)GetSvgTextHtml(text))
            }
            @if (_previewLine.HasValue)
            {
              (double X1, double Y1, double X2, double Y2) = _previewLine.Value;
              <line x1="@SvgPct(X1)" y1="@SvgPct(Y1)" 
                    x2="@SvgPct(X2)" y2="@SvgPct(Y2)" 
                    stroke="@_strokeColor" 
                    stroke-width="2" 
                    stroke-dasharray="4,2" />
            }
            @if (_previewCircle.HasValue)
            {
              (double Cx, double Cy, double Radius) pc = _previewCircle.Value;
              <circle cx="@SvgPct(pc.Cx)" cy="@SvgPct(pc.Cy)" 
                      r="@SvgPct(pc.Radius)" 
                      stroke="@_strokeColor" 
                      stroke-width="2" 
                      fill="none" 
                      stroke-dasharray="4,2" />
            }
          </svg>
        </div>
      </div>

      <div class="col-lg-3 col-md-4">
        <div class="card">
          <div class="card-header">
            <h6 class="mb-0">Elements</h6>
          </div>
          <div class="card-body p-0">
            <ul class="list-group list-group-flush small">
              @{ var idx = 0; }
              @foreach (var line in _overlay.Lines)
              {
                var i = idx++;
                <li class="list-group-item d-flex justify-content-between align-items-center py-2 @(IsSelected("line", i) ? "active" : "")" 
                    @onclick='() => SelectElement("line", i)'>
                  <span>Line @(i + 1)</span>
                  <button class="btn btn-sm btn-outline-danger ms-2" 
                          @onclick='() => DeleteLine(i)' 
                          @onclick:stopPropagation>Del</button>
                </li>
              }
              @{ idx = 0; }
              @foreach (var circle in _overlay.Circles)
              {
                var i = idx++;
                <li class="list-group-item d-flex justify-content-between align-items-center py-2 @(IsSelected("circle", i) ? "active" : "")" 
                    @onclick='() => SelectElement("circle", i)'>
                  <span>Circle @(i + 1)</span>
                  <button class="btn btn-sm btn-outline-danger ms-2" 
                          @onclick='() => DeleteCircle(i)' 
                          @onclick:stopPropagation>Del</button>
                </li>
              }
              @{ idx = 0; }
              @foreach (var text in _overlay.Texts)
              {
                var i = idx++;
                <li class="list-group-item d-flex justify-content-between align-items-center py-2 @(IsSelected("text", i) ? "active" : "")" 
                    @onclick='() => SelectElement("text", i)'>
                  <span class="text-truncate me-2">@text.Text</span>
                  <button class="btn btn-sm btn-outline-danger flex-shrink-0" 
                          @onclick='() => DeleteText(i)' 
                          @onclick:stopPropagation>Del</button>
                </li>
              }
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>

  @if (_showTextDialog)
  {
    <div class="modal show d-block" tabindex="-1" style="background:rgba(0,0,0,0.5)">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">Add text</div>
          <div class="modal-body">
            <input @ref="_textInputRef" type="text" class="form-control" @bind="_pendingText" placeholder="Label text" />
          </div>
          <div class="modal-footer">
            <button class="btn btn-secondary" @onclick="CancelText">Cancel</button>
            <button class="btn btn-primary" @onclick="ConfirmText">OK</button>
          </div>
        </div>
      </div>
    </div>
  }
}

@code {
  [Parameter] public string? Topic { get; set; }
  [Parameter] public string? Name { get; set; }

  private bool _isCanvasMode => !string.IsNullOrEmpty(Topic) && !string.IsNullOrEmpty(Name);
  private string _imageUrl => _isCanvasMode ? $"img/{Topic}/{Name}" : "";
  private string ImageDetailsUrl => Topic != null && Name != null ? $"/imagedetails/{Uri.EscapeDataString(Topic)}/{Uri.EscapeDataString(Name)}" : "/";

  private List<string>? _topics;
  private string? _selectedTopic;
  private List<string>? _images;
  private Dictionary<(string, string), bool> _overlayExists = new();

  protected override async Task OnInitializedAsync()
  {
    _topics = await f2iDataService.GetMainTopics();
    if (_isCanvasMode)
    {
      var loaded = await f2iDataService.GetOverlayData(Topic!, Name!);
      if (loaded != null) _overlay = loaded;
    }
  }

  protected override async Task OnAfterRenderAsync(bool firstRender)
  {
    if (_showTextDialog)
    {
      try { await _textInputRef.FocusAsync(); } catch { }
    }
  }

  #region Canvas state and tools
  private enum EditorTool { Line, Circle, Text }
  private OverlayData _overlay = new();
  private readonly List<OverlayData> _undoStack = new();
  private static readonly JsonSerializerOptions JsonOptions = new() { PropertyNameCaseInsensitive = true };

  private EditorTool _tool = EditorTool.Line;
  private string _strokeColor = "#ffffff";
  private double _strokeWidth = 1;
  private int _fontSize = 14;

  private (double X1, double Y1, double X2, double Y2)? _previewLine;
  private (double Cx, double Cy, double Radius)? _previewCircle;
  private double? _lineStartX, _lineStartY;
  private double? _circleCx, _circleCy;
  private bool _isDrawing;
  private double? _crosshairX;
  private double? _crosshairY;

  private bool _showTextDialog;
  private double _pendingTextX, _pendingTextY;
  private string _pendingText = "";
  private string? _selectedType;
  private int _selectedIndex = -1;
  private ElementReference _textInputRef;

  private bool IsSelected(string type, int index) => _selectedType == type && _selectedIndex == index;

  private async Task<(double x, double y)?> GetPercentFromMouse(MouseEventArgs e)
  {
    try
    {
      var rect = await JS.InvokeAsync<CanvasRect>("overlayEditor.getCanvasRect", "canvas-container");
      if (rect == null || rect.Width <= 0 || rect.Height <= 0) return null;
      var x = (e.ClientX - rect.Left) / rect.Width * 100.0;
      var y = (e.ClientY - rect.Top) / rect.Height * 100.0;
      return (Math.Clamp(x, 0, 100), Math.Clamp(y, 0, 100));
    }
    catch { return null; }
  }

  private void PushUndo() => _undoStack.Add(CloneOverlay(_overlay));
  private static OverlayData CloneOverlay(OverlayData src)
  {
    var json = JsonSerializer.Serialize(src, JsonOptions);
    return JsonSerializer.Deserialize<OverlayData>(json, JsonOptions) ?? new OverlayData();
  }

  private async Task OnCanvasMouseDown(MouseEventArgs e)
  {
    var p = await GetPercentFromMouse(e);
    if (p == null) return;
    var (x, y) = p.Value;
    if (_tool == EditorTool.Line)
    {
      _lineStartX = x; _lineStartY = y;
      _previewLine = (x, y, x, y);
      _isDrawing = true;
    }
    else if (_tool == EditorTool.Circle)
    {
      _circleCx = x; _circleCy = y;
      _previewCircle = (x, y, 0);
      _isDrawing = true;
    }
    else if (_tool == EditorTool.Text)
    {
      _pendingTextX = x; _pendingTextY = y;
      _pendingText = "";
      _showTextDialog = true;
    }
    StateHasChanged();
  }

  private async Task OnCanvasMouseMove(MouseEventArgs e)
  {
    try
    {
      var rect = await JS.InvokeAsync<CanvasRect>("overlayEditor.getCanvasRect", "canvas-container");
      if (rect != null && rect.Width > 0 && rect.Height > 0)
      {
        _crosshairX = e.ClientX - rect.Left;
        _crosshairY = e.ClientY - rect.Top;
      }
    }
    catch { /* ignore */ }
    var p = await GetPercentFromMouse(e);
    if (p == null) return;
    var (x, y) = p.Value;
    if (_tool == EditorTool.Line && _isDrawing && _lineStartX.HasValue && _lineStartY.HasValue)
    {
      _previewLine = (_lineStartX.Value, _lineStartY.Value, x, y);
    }
    else if (_tool == EditorTool.Circle && _isDrawing && _circleCx.HasValue && _circleCy.HasValue)
      _previewCircle = (_circleCx.Value, _circleCy.Value, Math.Min(Math.Sqrt(Math.Pow(x - _circleCx.Value, 2) + Math.Pow(y - _circleCy.Value, 2)), 50));
    else if (!_isDrawing)
    {
      _previewLine = null;
      _previewCircle = null;
    }
    StateHasChanged();
  }

  private async Task OnCanvasMouseUp(MouseEventArgs e)
  {
    if (!_isDrawing) return;
    var p = await GetPercentFromMouse(e);
    if (p == null) return;
    var (x, y) = p.Value;
    if (_tool == EditorTool.Line && _lineStartX.HasValue && _lineStartY.HasValue)
    {
      var dx = Math.Abs(x - _lineStartX.Value); var dy = Math.Abs(y - _lineStartY.Value);
      if (dx >= 0.5 || dy >= 0.5)
      {
        PushUndo();
        _overlay.Lines.Add(new OverlayLine { X1 = _lineStartX.Value, Y1 = _lineStartY.Value, X2 = x, Y2 = y, Color = _strokeColor, StrokeWidth = _strokeWidth, UsePercentage = true });
      }
    }
    else if (_tool == EditorTool.Circle && _circleCx.HasValue && _circleCy.HasValue)
    {
      var r = Math.Sqrt(Math.Pow(x - _circleCx.Value, 2) + Math.Pow(y - _circleCy.Value, 2));
      PushUndo();
      _overlay.Circles.Add(new OverlayCircle { Cx = _circleCx.Value, Cy = _circleCy.Value, Radius = Math.Min(r, 50), Color = _strokeColor, StrokeWidth = _strokeWidth, Fill = false, UsePercentage = true });
    }
    _lineStartX = _lineStartY = _circleCx = _circleCy = null;
    _previewLine = null;
    _previewCircle = null;
    _isDrawing = false;
    StateHasChanged();
  }

  private void OnCanvasMouseLeave()
  {
    _crosshairX = null;
    _crosshairY = null;
    if (!_isDrawing) { StateHasChanged(); return; }
    _lineStartX = _lineStartY = _circleCx = _circleCy = null;
    _previewLine = null;
    _previewCircle = null;
    _isDrawing = false;
    StateHasChanged();
  }

  private void ConfirmText()
  {
    PushUndo();
    _overlay.Texts.Add(new OverlayText { X = _pendingTextX, Y = _pendingTextY, Text = _pendingText ?? "", Color = _strokeColor, FontSize = _fontSize, FontFamily = "Arial, sans-serif", UsePercentage = true });
    _showTextDialog = false; _pendingText = "";
    StateHasChanged();
  }

  private void CancelText() { _showTextDialog = false; _pendingText = ""; StateHasChanged(); }
  private void SelectElement(string type, int index) { _selectedType = type; _selectedIndex = index; StateHasChanged(); }
  private void DeleteLine(int index) { PushUndo(); _overlay.Lines.RemoveAt(index); _selectedType = null; _selectedIndex = -1; StateHasChanged(); }
  private void DeleteCircle(int index) { PushUndo(); _overlay.Circles.RemoveAt(index); _selectedType = null; _selectedIndex = -1; StateHasChanged(); }
  private void DeleteText(int index) { PushUndo(); _overlay.Texts.RemoveAt(index); _selectedType = null; _selectedIndex = -1; StateHasChanged(); }

  private static string GetSvgTextHtml(OverlayText t)
  {
    var escaped = WebUtility.HtmlEncode(t.Text);
    return $"<text x=\"{SvgPct(t.X)}\" y=\"{SvgPct(t.Y)}\" fill=\"{t.Color}\" font-size=\"{t.FontSize}\" font-family=\"{t.FontFamily}\" dominant-baseline=\"text-before-edge\" text-anchor=\"start\">{escaped}</text>";
  }

  private static string SvgPct(double v) => v.ToString(CultureInfo.InvariantCulture) + "%";
  private static string SvgNum(double v) => v.ToString(CultureInfo.InvariantCulture);

  private void Undo()
  {
    if (_undoStack.Count == 0) return;
    _overlay = _undoStack[^1];
    _undoStack.RemoveAt(_undoStack.Count - 1);
    StateHasChanged();
  }

  private void Save()
  {
    if (!_isCanvasMode) return;
    f2iDataService.SaveOverlayData(Topic!, Name!, _overlay);
    StateHasChanged();
  }

  private class CanvasRect { public double Left { get; set; } public double Top { get; set; } public double Width { get; set; } public double Height { get; set; } }
  #endregion
}
